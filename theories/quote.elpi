% [eucldiv N D M R] N = D * M + R
pred eucldiv o:int, i:int, o:int, i:int.
eucldiv N D M R :- var N, var M, !, declare_constraint (eucldiv N D M R) [N, M].
eucldiv N D M R :- var N, N is D * M + R.
eucldiv N D M R :- var M, M is N div D, R is N mod D.

pred positive-constant o:int, o:term.
positive-constant 1 {{ lib:num.pos.xH }}.
positive-constant N {{ lib:num.pos.xO lp:T }} :-
  eucldiv N 2 M 0, positive-constant M T.
positive-constant N {{ lib:num.pos.xI lp:T }} :-
  eucldiv N 2 M 1, positive-constant M T.

pred n-constant o:int, o:term.
n-constant N _ :- not (var N), N < 0, !, fail.
n-constant 0 {{ lib:num.N.N0 }} :- !.
n-constant N {{ lib:num.N.Npos lp:T }} :- !, positive-constant N T.

pred z-constant o:int, o:term.
z-constant N {{ lib:num.Z.Zneg lp:T }} :-
  N < 0, !, positive-constant {calc (~ N)} T.
z-constant 0 {{ lib:num.Z.Z0 }} :- !.
z-constant N {{ lib:num.Z.Zpos lp:T }} :- 0 < N, !, positive-constant N T.

pred nat-constant o:int, o:term.
nat-constant N _ :- not (var N), N < 0, !, fail.
nat-constant 0 {{ lib:num.nat.O }} :- !.
nat-constant SN SM :-
  var SM, 0 < SN, !,
  nat-constant {calc (SN - 1)} M,
  SM = {{ lib:num.nat.S lp:M }}.
nat-constant SN {{ lib:num.nat.S lp:M }} :-
  var SN, !, nat-constant N M, SN is N + 1.

pred list-constant o:term, o:list term, o:term.
list-constant T [] {{ @nil lp:T }} :- !.
list-constant T [X|XS] {{ @cons lp:T lp:X lp:XS' }} :- list-constant T XS XS'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred mem o:list term, o:term, o:int.
mem [X|_] X 0 :- !.
mem [_|XS] X M :- !, mem XS X N, M is N + 1.

pred close o:list term.
close [] :- !.
close [_|XS] :- close XS.

pred field-mode.

% [ring->field Ring Field]: [Field] is optionally a [fieldType] instance such
% that [GRing.Field.ringType Field = Ring].
pred ring->field i:term, o:option term.
ring->field Ring (some Field) :-
  field-mode,
  coq.unify-eq {{ GRing.Ring.sort lp:Ring }} {{ GRing.Field.sort lp:Field }} ok,
  !.
ring->field _ none.

% [quote.nat(1|2) Ring Input OutM Out VarMap]
% - [Ring] is a [ringType] instance,
% - [Input] is a term of type [nat],
% - [OutM] and [Out] are reified terms of [Input], and
% - [VarMap] is a variable map.
% [Input] of [quote.nat1] is possibly a constant that reduces to
% [S (..(S O)..)], but of [quote.nat2] is not.
pred quote.nat1 i:term, i:term, o:term, o:term, o:list term.
quote.nat1 _ In {{ @NatX lp:In }} Out _ :-
  % TODO: more efficient constant detection
  if field-mode (Out = {{ @FEc Z lp:Out' }}) (Out = {{ @PEc Z lp:Out' }}),
  nat-constant N { coq.reduction.vm.norm In {{ nat }} }, !,
  z-constant N Out'.
quote.nat1 Ring In OutM Out VarMap :- !,
  quote.nat2 Ring In OutM Out VarMap.

pred quote.nat2 i:term, i:term, o:term, o:term, o:list term.
quote.nat2 Ring {{ addn lp:In1 lp:In2 }}
                {{ @NatAdd lp:OutM1 lp:OutM2 }} Out VarMap :- !,
  if field-mode (Out = {{ @FEadd Z lp:Out1 lp:Out2 }})
                (Out = {{ @PEadd Z lp:Out1 lp:Out2 }}), !,
  quote.nat1 Ring In1 OutM1 Out1 VarMap, !,
  quote.nat1 Ring In2 OutM2 Out2 VarMap.
quote.nat2 Ring {{ S lp:In1 }} {{ NatSucc lp:OutM1 }} Out VarMap :- !,
  if field-mode (Out = {{ @FEadd Z (@FEI Z) lp:Out1 }})
                (Out = {{ @PEadd Z (@PEI Z) lp:Out1 }}), !,
  quote.nat2 Ring In1 OutM1 Out1 VarMap.
quote.nat2 Ring {{ muln lp:In1 lp:In2 }}
                {{ NatMul lp:OutM1 lp:OutM2 }} Out VarMap :- !,
  if field-mode (Out = {{ @FEmul Z lp:Out1 lp:Out2 }})
                (Out = {{ @PEmul Z lp:Out1 lp:Out2 }}), !,
  quote.nat1 Ring In1 OutM1 Out1 VarMap, !,
  quote.nat1 Ring In2 OutM2 Out2 VarMap.
quote.nat2 Ring {{ expn lp:In1 lp:In2 }}
                {{ NatExp lp:OutM1 lp:In2 }} Out VarMap :-
  if field-mode (Out = {{ @FEpow Z lp:Out1 lp:Out2 }})
                (Out = {{ @PEpow Z lp:Out1 lp:Out2 }}),
  nat-constant Exp { coq.reduction.vm.norm In2 {{ nat }} },
  !,
  quote.nat2 Ring In1 OutM1 Out1 VarMap, !,
  n-constant Exp Out2.
quote.nat2 Ring In {{ NatX lp:In }} Out VarMap :-
  if field-mode (Out = {{ @FEX Z lp:Out' }}) (Out = {{ @PEX Z lp:Out' }}),
  Zmodule = {{ GRing.Ring.zmodType lp:Ring }},
  mem VarMap {{ @GRing.natmul lp:Zmodule (@GRing.one lp:Ring) lp:In }} N,
  positive-constant {calc (N + 1)} Out',
  !.

% [quote.zmod SrcZmodule TgtRing MorphFun Morph Input OutM Out VarMap]
% - [SrcZmodule] is a [zmodType] instance,
% - [TgtRing] is a [ringType] instance,
% - [Morph] is an additive function from [SrcZmodule] to [TgtRing] whose
%   underlying function is [MorphFun],
% - [Input] is a term of type [SrcZmodule],
% - [OutM] and [Out] are reified terms of [Input], and
% - [VarMap] is a variable map.
pred quote.zmod i:term, i:term, i:(term -> term), i:term, i:term,
                o:term, o:term, o:list term.
% 0%R
quote.zmod SrcZmodule _ _ _ {{ @GRing.zero lp:SrcZmodule' }}
           {{ @Zmod0 lp:SrcZmodule }} Out _ :-
  if field-mode (Out = {{ @FEO Z }}) (Out = {{ @PEO Z }}),
  coq.unify-eq {{ @GRing.zero lp:SrcZmodule }}
               {{ @GRing.zero lp:SrcZmodule' }} ok,
  !.
% -%R
quote.zmod SrcZmodule TgtRing MorphFun Morph
           {{ @GRing.opp lp:SrcZmodule' lp:In1 }}
           {{ @ZmodOpp lp:SrcZmodule lp:OutM1 }} Out VarMap :-
  if field-mode (Out = {{ @FEopp Z lp:Out1 }}) (Out = {{ @PEopp Z lp:Out1 }}),
  coq.unify-eq {{ @GRing.opp lp:SrcZmodule }}
               {{ @GRing.opp lp:SrcZmodule' }} ok,
  !,
  quote.zmod SrcZmodule TgtRing MorphFun Morph In1 OutM1 Out1 VarMap.
% +%R
quote.zmod SrcZmodule TgtRing MorphFun Morph
           {{ @GRing.add lp:SrcZmodule' lp:In1 lp:In2 }}
           {{ @ZmodAdd lp:SrcZmodule lp:OutM1 lp:OutM2 }} Out VarMap :-
  if field-mode (Out = {{ @FEadd Z lp:Out1 lp:Out2 }})
                (Out = {{ @PEadd Z lp:Out1 lp:Out2 }}),
  coq.unify-eq {{ @GRing.add lp:SrcZmodule }}
               {{ @GRing.add lp:SrcZmodule' }} ok,
  !,
  quote.zmod SrcZmodule TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.zmod SrcZmodule TgtRing MorphFun Morph In2 OutM2 Out2 VarMap.
% (_ *+ _)%R
quote.zmod SrcZmodule TgtRing MorphFun Morph
           {{ @GRing.natmul lp:SrcZmodule' lp:In1 lp:In2 }}
           {{ @ZmodMuln lp:SrcZmodule lp:OutM1 lp:OutM2 }} Out VarMap :-
  if field-mode (Out = {{ @FEmul Z lp:Out1 lp:Out2 }})
                (Out = {{ @PEmul Z lp:Out1 lp:Out2 }}),
  coq.unify-eq SrcZmodule SrcZmodule' ok,
  !,
  quote.zmod SrcZmodule TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.nat1 TgtRing In2 OutM2 Out2 VarMap.
% (_ *~ _)%R
quote.zmod SrcZmodule TgtRing MorphFun Morph
           {{ @intmul lp:SrcZmodule' lp:In1 lp:In2 }}
           {{ @ZmodMulz lp:SrcZmodule lp:OutM1 lp:OutM2 }} Out VarMap :-
  if field-mode (Out = {{ @FEmul Z lp:Out1 lp:Out2 }})
                (Out = {{ @PEmul Z lp:Out1 lp:Out2 }}),
  coq.unify-eq SrcZmodule SrcZmodule' ok,
  TgtZmodule = {{ GRing.Ring.zmodType lp:TgtRing }},
  !,
  quote.zmod SrcZmodule TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.ring
    {{ int_Ring }} none TgtRing
    (n\ {{ @intmul lp:TgtZmodule (@GRing.one lp:TgtRing) lp:n }})
    {{ @intmul1_rmorphism lp:TgtRing }} In2 OutM2 Out2 VarMap.
% additive functions
quote.zmod SrcZmodule TgtRing MorphFun Morph In
           {{ @ZmodMorph lp:NewSrcZmodule lp:SrcZmodule lp:NewMorph lp:OutM }}
           Out VarMap :-
  TgtZmodule = {{ @GRing.Ring.zmodType lp:TgtRing }},
  NewMorphFun = (x\ {{ @GRing.Additive.apply
                       lp:NewSrcZmodule lp:SrcZmodule _ lp:NewMorph lp:x }}),
  coq.unify-eq In (NewMorphFun In1) ok,
  !,
  % TODO: for concrete additive functions, should we unpack [NewMorph]?
  CompMorph = {{ @GRing.comp_additive lp:NewSrcZmodule
                 lp:SrcZmodule lp:TgtZmodule lp:Morph lp:NewMorph }},
  quote.zmod NewSrcZmodule TgtRing (x\ MorphFun (NewMorphFun x)) CompMorph
             In1 OutM Out VarMap.
% variables
quote.zmod SrcZmodule _ MorphFun _ In
           {{ @ZmodX lp:SrcZmodule lp:In }} Out VarMap :-
  if field-mode (Out = {{ @FEX Z lp:Pos }}) (Out = {{ @PEX Z lp:Pos }}),
  mem VarMap (MorphFun In) N,
  positive-constant {calc (N + 1)} Pos,
  !.
quote.zmod _ _ _ _ In _ _ _ :- coq.error "Unknown" {coq.term->string In}.

% [quote.ring SrcRing SrcField TgtRing MorphFun Morph Input OutM Out VarMap]
% - [SrcRing] and [TgtRing] are [ringType] instances,
% - [SrcField] is optionally a [fieldType] instance such that
%   [GRing.Field.ringType SrcField = SrcRing],
% - [Morph] is a ring morphism from [SrcRing] to [TgtRing] whose underlying
%   function is [MorphFun],
% - [Input] is a term of type [SrcRing],
% - [OutM] and [Out] are reified terms of [Input], and
% - [VarMap] is a variable map.
pred quote.ring i:term, i:option term, i:term, i:(term -> term), i:term,
                i:term, o:term, o:term, o:list term.
% 0%R
quote.ring SrcRing _ _ _ _ {{ @GRing.zero lp:SrcZmodule }}
           {{ @Ring0 lp:SrcRing }} Out _ :-
  if field-mode (Out = {{ @FEO Z }}) (Out = {{ @PEO Z }}),
  coq.unify-eq {{ @GRing.zero lp:SrcZmodule }}
               {{ @GRing.zero (GRing.Ring.zmodType lp:SrcRing) }} ok,
  !.
% -%R
quote.ring SrcRing SrcField TgtRing MorphFun Morph
           {{ @GRing.opp lp:SrcZmodule lp:In1 }}
           {{ @RingOpp lp:SrcRing lp:OutM1 }} Out VarMap :-
  if field-mode (Out = {{ @FEopp Z lp:Out1 }}) (Out = {{ @PEopp Z lp:Out1 }}),
  coq.unify-eq {{ @GRing.opp lp:SrcZmodule }}
               {{ @GRing.opp (GRing.Ring.zmodType lp:SrcRing) }} ok,
  !,
  quote.ring SrcRing SrcField TgtRing MorphFun Morph In1 OutM1 Out1 VarMap.
% +%R
quote.ring SrcRing SrcField TgtRing MorphFun Morph
           {{ @GRing.add lp:SrcZmodule lp:In1 lp:In2 }}
           {{ @RingAdd lp:SrcRing lp:OutM1 lp:OutM2 }} Out VarMap :-
  if field-mode (Out = {{ @FEadd Z lp:Out1 lp:Out2 }})
                (Out = {{ @PEadd Z lp:Out1 lp:Out2 }}),
  coq.unify-eq {{ @GRing.add lp:SrcZmodule }}
               {{ @GRing.add (GRing.Ring.zmodType lp:SrcRing) }} ok,
  !,
  quote.ring SrcRing SrcField TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.ring SrcRing SrcField TgtRing MorphFun Morph In2 OutM2 Out2 VarMap.
% (_ *+ _)%R
quote.ring SrcRing SrcField TgtRing MorphFun Morph
           {{ @GRing.natmul lp:SrcZmodule lp:In1 lp:In2 }}
           {{ @RingMuln lp:SrcRing lp:OutM1 lp:OutM2 }} Out VarMap :-
  if field-mode (Out = {{ @FEmul Z lp:Out1 lp:Out2 }})
                (Out = {{ @PEmul Z lp:Out1 lp:Out2 }}),
  coq.unify-eq SrcZmodule {{ @GRing.Ring.zmodType lp:SrcRing }} ok,
  !,
  quote.ring SrcRing SrcField TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.nat1 TgtRing In2 OutM2 Out2 VarMap.
% (_ *~ _)%R
quote.ring SrcRing SrcField TgtRing MorphFun Morph
           {{ @intmul lp:SrcZmodule lp:In1 lp:In2 }}
           {{ @RingMulz lp:SrcRing lp:OutM1 lp:OutM2 }} Out VarMap :-
  if field-mode (Out = {{ @FEmul Z lp:Out1 lp:Out2 }})
                (Out = {{ @PEmul Z lp:Out1 lp:Out2 }}),
  coq.unify-eq SrcZmodule {{ @GRing.Ring.zmodType lp:SrcRing }} ok,
  TgtZmodule = {{ GRing.Ring.zmodType lp:TgtRing }},
  !,
  quote.ring SrcRing SrcField TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.ring
    {{ int_Ring }} none TgtRing
    (n\ {{ @intmul lp:TgtZmodule (@GRing.one lp:TgtRing) lp:n }})
    {{ @intmul1_rmorphism lp:TgtRing }} In2 OutM2 Out2 VarMap.
% 1%R
quote.ring SrcRing _ _ _ _ {{ @GRing.one lp:SrcRing' }}
           {{ @Ring1 lp:SrcRing }} Out _ :-
  if field-mode (Out = {{ @FEI Z }}) (Out = {{ @PEI Z }}),
  coq.unify-eq {{ @GRing.one lp:SrcRing' }} {{ @GRing.one lp:SrcRing }} ok,
  !.
% *%R
quote.ring SrcRing SrcField TgtRing MorphFun Morph
           {{ @GRing.mul lp:SrcRing' lp:In1 lp:In2 }}
           {{ @RingMul lp:SrcRing lp:OutM1 lp:OutM2 }} Out VarMap :-
  if field-mode (Out = {{ @FEmul Z lp:Out1 lp:Out2 }})
                (Out = {{ @PEmul Z lp:Out1 lp:Out2 }}),
  coq.unify-eq {{ @GRing.mul lp:SrcRing' }} {{ @GRing.mul lp:SrcRing }} ok,
  !,
  quote.ring SrcRing SrcField TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.ring SrcRing SrcField TgtRing MorphFun Morph In2 OutM2 Out2 VarMap.
% (_ ^+ _)%R
% TODO: Treat [GRing.exp] as morphisms
quote.ring SrcRing SrcField TgtRing MorphFun Morph
           {{ @GRing.exp lp:SrcRing' lp:In1 lp:In2 }}
           {{ @RingExpn lp:SrcRing lp:OutM1 lp:In2 }} Out VarMap :-
  if field-mode (Out = {{ @FEpow Z lp:Out1 lp:Out2 }})
                (Out = {{ @PEpow Z lp:Out1 lp:Out2 }}),
  coq.unify-eq SrcRing' SrcRing ok,
  nat-constant Exp { coq.reduction.vm.norm In2 {{ nat }} },
  !,
  quote.ring SrcRing SrcField TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  n-constant Exp Out2.
% (_ ^ _)%R
quote.ring SrcRing SrcField TgtRing MorphFun Morph
           {{ @exprz lp:SrcUnitRing lp:In1 lp:In2 }}
           {{ @RingExpn lp:SrcRing lp:OutM1 lp:In2' }} Out VarMap :-
  if field-mode (Out = {{ @FEpow Z lp:Out1 lp:Out2 }})
                (Out = {{ @PEpow Z lp:Out1 lp:Out2 }}),
  coq.unify-eq {{ GRing.UnitRing.ringType lp:SrcUnitRing }} SrcRing ok,
  coq.unify-eq In2 {{ Posz lp:In2' }} ok,
  nat-constant Exp { coq.reduction.vm.norm In2' {{ nat }} },
  !,
  quote.ring SrcRing SrcField TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  n-constant Exp Out2.
% _^-1
quote.ring SrcRing (some SrcField) TgtRing MorphFun Morph
           {{ @GRing.inv lp:SrcUnitRing' lp:In1 }}
           {{ @RingInv lp:SrcField lp:OutM1 }} {{ @FEinv Z lp:Out1 }} VarMap :-
  field-mode,
  coq.unify-eq {{ @GRing.inv lp:SrcUnitRing' }}
               {{ @GRing.inv (GRing.Field.unitRingType lp:SrcField) }} ok,
  !,
  quote.ring SrcRing (some SrcField) TgtRing MorphFun Morph
             In1 OutM1 Out1 VarMap.
% Posz
quote.ring SrcRing _ TgtRing _ _
           {{ Posz lp:In }} {{ @RingPosz lp:OutM }} Out VarMap :-
  coq.unify-eq {{ int_Ring }} SrcRing ok,
  !,
  quote.nat1 TgtRing In OutM Out VarMap.
% Negz
quote.ring SrcRing _ TgtRing _ _ {{ Negz lp:In }}
           {{ @RingNegz lp:OutM' }} Out VarMap :-
  if field-mode (Out = {{ @FEopp Z (@FEadd Z (@FEI Z) lp:Out') }})
                (Out = {{ @PEopp Z (@PEadd Z (@PEI Z) lp:Out') }}),
  coq.unify-eq {{ int_Ring }} SrcRing ok,
  !,
  quote.nat1 TgtRing In OutM' Out' VarMap.
% morphisms
quote.ring SrcRing _ TgtRing MorphFun Morph In
           {{ @RingMorph lp:NewSrcRing lp:SrcRing lp:NewMorph lp:OutM }}
           Out VarMap :-
  NewMorphFun = (x\ {{ @GRing.RMorphism.apply
                       lp:NewSrcRing lp:SrcRing _ lp:NewMorph lp:x }}),
  coq.unify-eq In (NewMorphFun In1) ok,
  !,
  % TODO: for concrete morphisms, should we unpack [NewMorph]?
  CompMorph = {{ @GRing.comp_rmorphism lp:NewSrcRing
                   lp:SrcRing lp:TgtRing lp:Morph lp:NewMorph }},
  quote.ring NewSrcRing { ring->field NewSrcRing } TgtRing
             (x\ MorphFun (NewMorphFun x)) CompMorph In1 OutM Out VarMap.
% additive functions
quote.ring SrcRing _ TgtRing MorphFun Morph In
           {{ @RingMorph' lp:NewSrcZmodule lp:SrcRing lp:NewMorph lp:OutM }}
           Out VarMap :-
  SrcZmodule = {{ GRing.Ring.zmodType lp:SrcRing }},
  TgtZmodule = {{ GRing.Ring.zmodType lp:TgtRing }},
  NewMorphFun = (x\ {{ @GRing.Additive.apply lp:NewSrcZmodule
                       lp:SrcZmodule _ lp:NewMorph lp:x }}),
  coq.unify-eq In (NewMorphFun In1) ok,
  !,
  % TODO: for concrete additive functions, should we unpack [NewMorph]?
  Morph' = {{ GRing.RMorphism.additive lp:SrcRing lp:TgtRing
              (Phant (GRing.Ring.sort lp:SrcRing -> GRing.Ring.sort lp:TgtRing))
              lp:Morph }},
  CompMorph = {{ @GRing.comp_additive lp:NewSrcZmodule
                 lp:SrcZmodule lp:TgtZmodule lp:Morph' lp:NewMorph }},
  quote.zmod NewSrcZmodule TgtRing
             (x\ MorphFun (NewMorphFun x)) CompMorph In1 OutM Out VarMap.
% variables
quote.ring SrcRing _ _ MorphFun _ In {{ @RingX lp:SrcRing lp:In }} Out VarMap :-
  if field-mode (Out = {{ @FEX Z lp:Pos }}) (Out = {{ @PEX Z lp:Pos }}),
  mem VarMap (MorphFun In) N,
  positive-constant {calc (N + 1)} Pos,
  !.
quote.ring _ _ _ _ _ In _ _ _ :- coq.error "Unknown" {coq.term->string In}.
% TODO: converse ring
