%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Misc utils

pred list-constant o:term, o:list term, o:term.
list-constant T [] {{ @nil lp:T }} :- !.
list-constant T [X|XS] {{ @cons lp:T lp:X lp:XS' }} :- list-constant T XS XS'.

pred mem o:list term, o:term, o:term.
mem [X|_] X {{ 1%positive }}.
mem [_|XS] X M :- !, mem XS X N,
  coq.reduction.vm.norm {{ Pos.succ lp:N }} {{ positive }} M.

pred ground-pos i:term.
ground-pos {{ xH }}.
ground-pos {{ xO lp:P }} :- !, ground-pos P.
ground-pos {{ xI lp:P }} :- !, ground-pos P.

pred ground-N i:term.
ground-N {{ N0 }}.
ground-N {{ Npos lp:P }} :- !, ground-pos P.

pred ground-Z i:term.
ground-Z {{ Z0 }}.
ground-Z {{ Zpos lp:P }} :- !, ground-pos P.
ground-Z {{ Zneg lp:P }} :- !, ground-pos P.

pred reduction-N i:term, o:term.
reduction-N I O :- coq.reduction.vm.norm I {{ N }} O, ground-N O.

pred reduction-Z i:term, o:term.
reduction-Z I O :- coq.reduction.vm.norm I {{ Z }} O, ground-Z O.

pred nat->N i:term, o:term.
nat->N {{ Init.Nat.of_num_uint lp:X }} XN :-
  reduction-N {{ N.of_num_uint lp:X }} XN.
nat->N {{ lp:X }} XN :- reduction-N {{ N.of_nat lp:X }} XN.

pred nat->Z i:term, o:term.
nat->Z {{ Init.Nat.of_num_uint lp:X }} XZ :-
  reduction-Z {{ Z.of_num_uint lp:X }} XZ.
nat->Z {{ lp:X }} XZ :- reduction-Z {{ Z.of_nat lp:X }} XZ.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Sum type to contain either realDomainType or realFieldType
% and casts from both to various substructures

% ring or field
kind rf type.
type ring term -> rf.
type field term -> rf.

pred rf->sort o:rf, o:term.
rf->sort (field F) T :- coq.unify-eq {{ Num.RealField.sort lp:F }} T ok.
rf->sort (ring R) T :- coq.unify-eq {{ Num.RealDomain.sort lp:R }} T ok.

pred rf->eq o:rf, o:term.
rf->eq (field F) T :- coq.unify-eq {{ Num.RealField.eqType lp:F }} T ok.
rf->eq (ring R) T :- coq.unify-eq {{ Num.RealDomain.eqType lp:R }} T ok.

pred rf->porder o:rf, o:term.
rf->porder (field F) T :- coq.unify-eq {{ Num.RealField.porderType lp:F }} T ok.
rf->porder (ring R) T :- coq.unify-eq {{ Num.RealDomain.porderType lp:R }} T ok.

pred rf->zmod o:rf, o:term.
rf->zmod (field F) T :- coq.unify-eq {{ Num.RealField.zmodType lp:F }} T ok.
rf->zmod (ring R) T :- coq.unify-eq {{ Num.RealDomain.zmodType lp:R }} T ok.

pred rf->ring o:rf, o:term.
rf->ring (field F) T :- coq.unify-eq {{ Num.RealField.ringType lp:F }} T ok.
rf->ring (ring R) T :- coq.unify-eq {{ Num.RealDomain.ringType lp:R }} T ok.

pred rf->unitRing o:rf, o:term.
rf->unitRing (field F) T :-
  coq.unify-eq {{ Num.RealField.unitRingType lp:F }} T ok.
rf->unitRing (ring R) T :-
  coq.unify-eq {{ Num.RealDomain.unitRingType lp:R }} T ok.

% [field-mode] is true if we are on a realFieldType,
% otherwise we are on a realDomainType.
pred field-mode.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parse goal (and hypotheses) to extract a realFieldType or realDomainType
% from (in)equalities it contains

% ring or field structure from a term of type bool
pred rfstr.bool i:term, o:rf.
rfstr.bool {{ _ ==> lp:Type }} F :- rfstr.bool Type F.
rfstr.bool {{ lp:Type ==> _ }} F :- rfstr.bool Type F.
rfstr.bool {{ ~~ lp:Type }} F :- rfstr.bool Type F.
rfstr.bool {{ _ && lp:Type }} F :- rfstr.bool Type F.
rfstr.bool {{ lp:Type && _ }} F :- rfstr.bool Type F.
rfstr.bool {{ _ || lp:Type }} F :- rfstr.bool Type F.
rfstr.bool {{ lp:Type || _ }} F :- rfstr.bool Type F.
rfstr.bool {{ @Order.le _ lp:Ty _ _ }} F :- field-mode,
  rf->porder F Ty, F = field _.
rfstr.bool {{ @Order.lt _ lp:Ty _ _ }} F :- field-mode,
  rf->porder F Ty, F = field _.
rfstr.bool {{ @Order.le _ lp:Ty _ _ }} R :- not field-mode,
  rf->porder R Ty, R = ring _.
rfstr.bool {{ @Order.lt _ lp:Ty _ _ }} R :- not field-mode,
  rf->porder R Ty, R = ring _.

% ring or field structure from a term of type Prop
pred rfstr.prop i:term, o:rf.
rfstr.prop {{ _ -> lp:Type }} F :- rfstr.prop Type F.
rfstr.prop {{ lp:Type -> _ }} F :- rfstr.prop Type F.
rfstr.prop {{ iff _ lp:Type }} F :- rfstr.prop Type F.
rfstr.prop {{ iff lp:Type _ }} F :- rfstr.prop Type F.
rfstr.prop {{ ~ lp:Type }} F :- rfstr.prop Type F.
rfstr.prop {{ _ /\ lp:Type }} F :- rfstr.prop Type F.
rfstr.prop {{ lp:Type /\ _ }} F :- rfstr.prop Type F.
rfstr.prop {{ _ \/ lp:Type }} F :- rfstr.prop Type F.
rfstr.prop {{ lp:Type \/ _ }} F :- rfstr.prop Type F.
rfstr.prop {{ is_true lp:Type }} F :- rfstr.bool Type F.
rfstr.prop {{ @eq bool _ lp:Type }} F :- rfstr.bool Type F.
rfstr.prop {{ @eq bool lp:Type _ }} F :- rfstr.bool Type F.
rfstr.prop {{ @eq lp:Ty _ _ }} F :- field-mode, rf->sort F Ty, F = field _.
rfstr.prop {{ @eq lp:Ty _ _ }} R :- not field-mode, rf->sort R Ty, R = ring _.

pred rfstr.hyps i:list prop, o:rf.
rfstr.hyps [decl _ _ H|_] F :- rfstr.prop H F.
rfstr.hyps [_|Ctx] F :- rfstr.hyps Ctx F.

pred rfstr i:list prop, i:term, o:rf.
rfstr _ Type F :- field-mode => rfstr.prop Type F.
rfstr _ Type R :- rfstr.prop Type R.
rfstr Ctx _ F :- field-mode => rfstr.hyps Ctx F.
rfstr Ctx _ R :- rfstr.hyps Ctx R.
rfstr _ _ _ :- coq.ltac.fail _ "Cannot find a realDomainType".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Reification procedure

% [quote.cstr F In Out] reifies integer constants
% - [F] is a [realDomainType] or [realFieldType] instance,
% - [In] is a term of type [F],
% - [Out] is a reified constant of type [Z]
pred quote.cstr i:rf, i:term, o:term.
quote.cstr F {{ GRing.zero lp:Z }} {{ Z0 }} :- rf->zmod F Z.
quote.cstr F {{ GRing.one lp:R }} {{ (Zpos 1) }} :- rf->ring F R.
quote.cstr F {{ @GRing.natmul lp:Z (GRing.one lp:R) lp:X }} XZ :-
  rf->zmod F Z, rf->ring F R, nat->Z X XZ.

% [quote.cstf F In Out] reifies rational constants
% - [F] is a [realFieldType] instance,
% - [In] is a term of type [F],
% - [Out] is a reified constant of type [Q]
pred quote.cstf i:rf, i:term, o:term.
quote.cstf F {{ @GRing.inv lp:U (@GRing.natmul lp:Z (GRing.one lp:R) lp:X) }}
    E' :- rf->unitRing F U, rf->zmod F Z, rf->ring F R,
  nat->N X XN, XN = {{ Npos lp:XP }}, !, E' = {{ Qmake 1 lp:XP }}.

% [quote.expr F In Out VarMap] reifies arithmetic expressions
% - [F] is a [realDomainType] or [realFieldType] instance,
% - [In] is a term of type [F],
% - [Out] is a reified expression of type [PExpr Q]
% - [VarMap] is a variable map, that is a list of terms of type [F].
pred quote.expr i:rf, i:term, o:term, o:list term.
quote.expr F {{ @GRing.add lp:Z lp:E1 lp:E2 }} E' VM :- rf->zmod F Z, !,
  quote.expr F E1 E1' VM, !, quote.expr F E2 E2' VM, !,
  E' = {{ PEadd lp:E1' lp:E2' }}.
quote.expr F {{ @GRing.opp lp:Z lp:E }} {{ PEopp lp:E' }} VM :- rf->zmod F Z, !,
  quote.expr F E E' VM.
quote.expr F {{ @GRing.mul lp:R lp:E1 lp:E2 }} E' VM :- rf->ring F R, !,
  quote.expr F E1 E1' VM, !, quote.expr F E2 E2' VM, !,
  E' = {{ PEmul lp:E1' lp:E2' }}.
quote.expr F {{ @GRing.exp lp:R lp:E1 lp:X }} E' VM :-
  rf->ring F R, nat->N X XN, !,
  quote.expr F E1 E1' VM, E' = {{ PEpow lp:E1' lp:XN }}.
quote.expr F E {{ PEc (Qmake lp:Z 1) }} _ :- quote.cstr F E Z.
quote.expr F E {{ PEc lp:Q }} _ :- F = field _, quote.cstf F E Q.
quote.expr F {{ lp:X : _ }} X' VM :- !, quote.expr F X X' VM.
quote.expr _ X Out VarMap :- !, mem VarMap X N, Out = {{ PEX lp:N }}.

% [quote.bop2 F In Out VarMap] reifies boolean (in)equalities
% - [F] is a [realDomainType] or [realFieldType] instance,
% - [In] is a term of type [bool],
% - [Out] is a reified expression of type [Formula Q]
% - [VarMap] is a variable map, that is a list of terms of type [F].
pred quote.bop2 i:rf, i:term, o:term, o:list term.
quote.bop2 F {{ @Order.le _ lp:O lp:X lp:Y }} F' VM :- rf->porder F O, !,
  quote.expr F X X' VM, !, quote.expr F Y Y' VM, !,
  F' = {{ Build_Formula lp:X' OpLe lp:Y' }}.
quote.bop2 F {{ @Order.lt _ lp:O lp:X lp:Y }} F' VM :- rf->porder F O, !,
  quote.expr F X X' VM, !, quote.expr F Y Y' VM, !,
  F' = {{ Build_Formula lp:X' OpLt lp:Y' }}.
quote.bop2 F {{ @eqtype.eq_op lp:T lp:X lp:Y) }} F' VM :- rf->eq F T, !,
  quote.expr F X X' VM, !, quote.expr F Y Y' VM, !,
  F' = {{ Build_Formula lp:X' OpEq lp:Y' }}.

% [quote.pop2 F In Out VarMap] reifies (in)equalities of type Prop
% - [F] is a [realDomainType] or [realFieldType] instance,
% - [In] is a term of type [Prop],
% - [Out] is a reified expression of type [Formula Q]
% - [VarMap] is a variable map, that is a list of terms of type [F].
pred quote.pop2 i:rf, i:term, o:term, o:list term.
quote.pop2 F {{ is_true lp:E }} F' VM :- quote.bop2 F E F' VM.
quote.pop2 F {{ @eq lp:T lp:X lp:Y) }} F' VM :- rf->sort F T, !,
  quote.expr F X X' VM, !, quote.expr F Y Y' VM, !,
  F' = {{ Build_Formula lp:X' OpEq lp:Y' }}.

% [quote.bool F In Out VarMap] reifies boolean formulas
% - [F] is a [realDomainType] or [realFieldType] instance,
% - [In] is a term of type [bool],
% - [Out] is a reified formula of type [BFormula (Formula Q) Tauto.isBool]
% - [VarMap] is a variable map, that is a list of terms of type [F].
pred quote.bool i:rf, i:term, o:term, o:list term.
quote.bool F {{ lp:F1 ==> lp:F2 }} {{ IMPL lp:F1' None lp:F2' }} VM :- !,
  quote.bool F F1 F1' VM, !, quote.bool F F2 F2' VM.
quote.bool F {{ lp:F1 && lp:F2 }} {{ AND lp:F1' lp:F2' }} VM :- !,
  quote.bool F F1 F1' VM, !, quote.bool F F2 F2' VM.
quote.bool F {{ lp:F1 || lp:F2 }} {{ OR lp:F1' lp:F2' }} VM :- !,
  quote.bool F F1 F1' VM, !, quote.bool F F2 F2' VM.
quote.bool F {{ ~~ lp:F1 }} {{ NOT lp:F1' }} VM :- !, quote.bool F F1 F1' VM.
quote.bool _ {{ true }} {{ TT Tauto.isBool }} _.
quote.bool _ {{ false }} {{ FF Tauto.isBool }} _.
quote.bool F A {{ A Tauto.isBool lp:A' tt }} VM :- quote.bop2 F A A' VM.
quote.bool _ X {{ X Tauto.isBool lp:X }} _.

% [quote.prop F In Out VarMap] reifies formulas of type Prop
% - [F] is a [realDomainType] or [realFieldType] instance,
% - [In] is a term of type [Prop],
% - [Out] is a reified formula of type [BFormula (Formula Q) Tauto.isProp]
% - [VarMap] is a variable map, that is a list of terms of type [F].
pred quote.prop i:rf, i:term, o:term, o:list term.
quote.prop F {{ lp:F1 -> lp:F2 }} {{ IMPL lp:F1' None lp:F2' }} VM :- !,
  quote.prop F F1 F1' VM, !, quote.prop F F2 F2' VM.
quote.prop F {{ iff lp:F1 lp:F2 }} {{ IFF lp:F1' lp:F2' }} VM :- !,
  quote.prop F F1 F1' VM, !, quote.prop F F2 F2' VM.
quote.prop F {{ lp:F1 /\ lp:F2 }} {{ AND lp:F1' lp:F2' }} VM :- !,
  quote.prop F F1 F1' VM, !, quote.prop F F2 F2' VM.
quote.prop F {{ lp:F1 \/ lp:F2 }} {{ OR lp:F1' lp:F2' }} VM :- !,
  quote.prop F F1 F1' VM, !, quote.prop F F2 F2' VM.
quote.prop F {{ ~ lp:F1 }} {{ NOT lp:F1' }} VM :- !, quote.prop F F1 F1' VM.
quote.prop _ {{ True }} {{ TT Tauto.isProp }} _.
quote.prop _ {{ False }} {{ FF Tauto.isProp }} _.
quote.prop F {{ is_true lp:F1 }} {{ EQ lp:F1' (TT Tauto.isBool) }} VM :- !,
  quote.bool F F1 F1' VM.
quote.prop F {{ @eq bool lp:F1 lp:F2 }} {{ EQ lp:F1' lp:F2' }} VM :- !,
  quote.bool F F1 F1' VM, !, quote.bool F F2 F2' VM.
quote.prop F A {{ A Tauto.isProp lp:A' tt }} VM :- quote.pop2 F A A' VM.
quote.prop _ X {{ X Tauto.isProp lp:X }} _.

% [simplify.bool In Out] reduces a boolean formula to [X _]
% when it doesn't contain any arithmetic part
% - [In] is a reified formula of type [BFormula (Formula Q) Tauto.isBool],
% - [Out] is a simplified formula of type [BFormula (Formula Q) Tauto.isBool]
pred simplify.bool i:term, o:term.
simplify.bool {{ IMPL (X _ lp:F1) None (X _ lp:F2) }} F' :-
  F' = {{ X Tauto.isBool (lp:F1 ==> lp:F2) }}.
simplify.bool {{ IMPL lp:F1 None lp:F2 }} {{ IMPL lp:F1' None lp:F2' }} :-
  simplify.bool F1 F1', simplify.bool F2 F2'.
simplify.bool {{ AND (X _ lp:F1) (X _ lp:F2) }} F' :-
  F' = {{ X Tauto.isBool (lp:F1 && lp:F2) }}.
simplify.bool {{ AND lp:F1 lp:F2 }} {{ AND lp:F1' lp:F2' }} :-
  simplify.bool F1 F1', simplify.bool F2 F2'.
simplify.bool {{ OR (X _ lp:F1) (X _ lp:F2) }} F' :-
  F' = {{ X Tauto.isBool (lp:F1 || lp:F2) }}.
simplify.bool {{ OR lp:F1 lp:F2 }} {{ OR lp:F1' lp:F2' }} :-
  simplify.bool F1 F1', simplify.bool F2 F2'.
simplify.bool {{ NOT (X _ lp:F) }} {{ X Tauto.isProp (~~ lp:F) }}.
simplify.bool {{ NOT lp:F }} {{ NOT lp:F' }} :- simplify.bool F F'.
simplify.bool X X.

% [simplify.prop In Out] reduces a formula to [X _]
% when it doesn't contain any arithmetic part
% - [In] is a reified formula of type [BFormula (Formula Q) Tauto.isProp],
% - [Out] is a simplified formula of type [BFormula (Formula Q) Tauto.isProp]
pred simplify.prop i:term, o:term.
simplify.prop {{ IMPL (X _ lp:F1) None (X _ lp:F2) }} F' :-
  F' = {{ X Tauto.isProp (lp:F1 -> lp:F2) }}.
simplify.prop {{ IMPL lp:F1 None lp:F2 }} {{ IMPL lp:F1' None lp:F2' }} :-
  simplify.prop F1 F1', simplify.prop F2 F2'.
simplify.prop {{ IFF (X _ lp:F1) (X _ lp:F2) }} F' :-
  F' = {{ X Tauto.isProp (iff lp:F1 lp:F2) }}.
simplify.prop {{ IFF lp:F1 lp:F2 }} {{ IFF lp:F1' lp:F2' }} :-
  simplify.prop F1 F1', simplify.prop F2 F2'.
simplify.prop {{ AND (X _ lp:F1) (X _ lp:F2) }} F' :-
  F' = {{ X Tauto.isProp (lp:F1 /\ lp:F2) }}.
simplify.prop {{ AND lp:F1 lp:F2 }} {{ AND lp:F1' lp:F2' }} :-
  simplify.prop F1 F1', simplify.prop F2 F2'.
simplify.prop {{ OR (X _ lp:F1) (X _ lp:F2) }} F' :-
  F' = {{ X Tauto.isProp (lp:F1 \/ lp:F2) }}.
simplify.prop {{ OR lp:F1 lp:F2 }} {{ OR lp:F1' lp:F2' }} :-
  simplify.prop F1 F1', simplify.prop F2 F2'.
simplify.prop {{ NOT (X _ lp:F) }} {{ X Tauto.isProp (~ lp:F) }}.
simplify.prop {{ NOT lp:F }} {{ NOT lp:F' }} :- simplify.prop F F'.
simplify.prop {{ EQ (X _ lp:F1) (X _ lp:F2) }} F' :-
  F' = {{ X Tauto.isProp (lp:F1 = lp:F2) }}.
simplify.prop {{ EQ lp:F1 lp:F2 }} {{ EQ lp:F1' lp:F2' }} :-
  simplify.bool F1 F1', simplify.bool F2 F2'.
simplify.prop X X.

% [quote F In Out VarMap] reifies formulas of type Prop
% - [F] is a [realDomainType] or [realFieldType] instance,
% - [In] is a term of type [Prop],
% - [Out] is a reified formula of type [BFormula (Formula Q) Tauto.isProp]
% - [VarMap] is a variable map, that is a list of terms of type [F].
pred quote i:rf, i:term, o:term, o:list term.
quote F In Out' VM :- quote.prop F In Out VM, simplify.prop Out Out'.

% [quote.hyps F Hyps Goal ReifiedGoal Out ReifiedOut VarMap] reifies hypotheses
% - [F] is a [realDomainType] or [realFieldType] instance,
% - [Hyps] are hypotheses
% - [Goal] is the goal, of type [Prop]
% - [ReifiedGoal] is the refied goal as a [BFormula (Formula Q) Tauto.isProp]
% - [Out] is a chain of implications including [Goal] and hypotheses in [Hyps]
%   that have some arithmetic content
% - [ReifiedOut] is a reified version of [Out]
%   as a [BFormula (Formula Q) Tauto.isProp]
% - [VarMap] is a variable map, that is a list of terms of type [F].
pred quote.hyps i:rf, i:list prop, i:term, i:term, o:term, o:term, o:list term.
quote.hyps F [decl _ _ H|Ctx] Type TypeF Type'' TypeF'' VM :-
  quote F H H' VM, not (H' = {{ X _ _ }}), !,
  quote.hyps F Ctx Type TypeF Type' TypeF' VM,
  Type'' = {{ lp:H -> lp:Type' }},
  TypeF'' = {{ IMPL lp:H' None lp:TypeF' }}.
quote.hyps F [decl _ _ _|Ctx] Type TypeF Type' TypeF' VM :- !,
  quote.hyps F Ctx Type TypeF Type' TypeF' VM.
quote.hyps F [def _ _ _ _|Ctx] Type TypeF Type' TypeF' VM :- !,
  quote.hyps F Ctx Type TypeF Type' TypeF' VM.
quote.hyps _ [] Type TypeF Type TypeF _.

% [exfalso_if_not_prop In Out Bool] changes [In] to [False]
% when [In] is not a [Prop] (and then set [Bool] to [true])
pred exfalso_if_not_prop i:term, o:term, o:term.
exfalso_if_not_prop Type Type {{ false }} :-
  coq.typecheck Type {{ Prop }} ok.
exfalso_if_not_prop _ {{ False }} {{ true }}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Main tactic

% The tactic takes three arguments, two strings [TacF] and [TacR]
% that are the names of the Ltac1 tactic to call respactively
% in the [realFieldType] and [realDomainType] case and a third argument [N],
% passed unchanged as first argument to the previous tactic.
% The tactics [TacF] or [TacR] will receive five arguments:
% - [N] above
% - [Efalso] a term of type [bool] indicating if the goal was changed to [False]
% - [Type''] a term of type [Prop], an implication with the goal
%   and selected hypotheses
% - [TypeF'] the reified [Type''] as a [BFormula (Formula Q) Tauto.isProp]
% - [VM''] a variable map, giving the interpretation to variables in [TypeF']
%   it is of type [VarMap.t F] where [F] is the carrier for the detected
%   [realFieldType] or [realDomainType]
solve (goal Ctx _Trigger Type _Proof [str TacF, str TacR, N] as G) GL :-
  exfalso_if_not_prop Type Type' Efalso,
  std.rev Ctx Ctx', !,
  rfstr Ctx' Type' F, !,
  quote F Type' TypeF VM, !,
  quote.hyps F Ctx' Type' TypeF Type'' TypeF' VM, !,
  std.assert-ok!
    (coq.typecheck TypeF' {{ BFormula (Formula Q) isProp }})
    "The reification produced an ill-typed result, this is a bug.",
  rf->sort F FS, list-constant FS VM VM',
  coq.reduction.vm.norm
    {{ Internals.vm_of_list lp:VM' }}
    {{ VarMap.t lp:FS }}
    VM'',
  (if (F = field _) (Tac = TacF) (Tac = TacR)),
  (coq.ltac.call Tac [N, trm Efalso, trm Type'', trm TypeF', trm VM''] G GL;
   coq.ltac.fail 0).
