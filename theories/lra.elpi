%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Misc utils

pred list-constant o:term, o:list term, o:term.
list-constant T [] {{ @nil lp:T }} :- !.
list-constant T [X|XS] {{ @cons lp:T lp:X lp:XS' }} :- list-constant T XS XS'.

pred mem o:list term, o:term, o:term.
mem [X|_] X {{ 1%positive }}.
mem [_|XS] X M :- !, mem XS X N,
  coq.reduction.vm.norm {{ Pos.succ lp:N }} {{ positive }} M.

pred ground-pos i:term.
ground-pos {{ xH }}.
ground-pos {{ xO lp:P }} :- !, ground-pos P.
ground-pos {{ xI lp:P }} :- !, ground-pos P.

pred ground-N i:term.
ground-N {{ N0 }}.
ground-N {{ Npos lp:P }} :- !, ground-pos P.

pred ground-Z i:term.
ground-Z {{ Z0 }}.
ground-Z {{ Zpos lp:P }} :- !, ground-pos P.
ground-Z {{ Zneg lp:P }} :- !, ground-pos P.

pred reduction-N i:term, o:term.
reduction-N I O :- coq.reduction.vm.norm I {{ N }} O, ground-N O.

pred reduction-Z i:term, o:term.
reduction-Z I O :- coq.reduction.vm.norm I {{ Z }} O, ground-Z O.

pred nat->N i:term, o:term.
nat->N {{ Init.Nat.of_num_uint lp:X }} XN :-
  reduction-N {{ N.of_num_uint lp:X }} XN.
nat->N {{ lp:X }} XN :- reduction-N {{ N.of_nat lp:X }} XN.

pred nat->Z i:term, o:term.
nat->Z {{ Init.Nat.of_num_uint lp:X }} XZ :-
  reduction-Z {{ Z.of_num_uint lp:X }} XZ.
nat->Z {{ lp:X }} XZ :- reduction-Z {{ Z.of_nat lp:X }} XZ.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Sum type to contain either realDomainType or realFieldType
% and casts from both to various substructures

% ring or field
kind rf type.
type ring term -> rf.
type field term -> rf.

pred rf->sort o:rf, o:term.
rf->sort (field F) T :- coq.unify-eq {{ Num.RealField.sort lp:F }} T ok.
rf->sort (ring R) T :- coq.unify-eq {{ Num.RealDomain.sort lp:R }} T ok.

pred rf->eq o:rf, o:term.
rf->eq (field F) T :- coq.unify-eq {{ Num.RealField.eqType lp:F }} T ok.
rf->eq (ring R) T :- coq.unify-eq {{ Num.RealDomain.eqType lp:R }} T ok.

pred rf->porder o:rf, o:term.
rf->porder (field F) T :- coq.unify-eq {{ Num.RealField.porderType lp:F }} T ok.
rf->porder (ring R) T :- coq.unify-eq {{ Num.RealDomain.porderType lp:R }} T ok.

pred rf->ring o:rf, o:term.
rf->ring (field F) T :- coq.unify-eq {{ Num.RealField.ringType lp:F }} T ok.
rf->ring (ring R) T :- coq.unify-eq {{ Num.RealDomain.ringType lp:R }} T ok.

pred rf->numDomain o:rf, o:term.
rf->numDomain (field F) D :-
  coq.unify-eq {{ Num.RealField.numDomainType lp:F }} D ok.
rf->numDomain (ring R) D :-
  coq.unify-eq {{ Num.RealDomain.numDomainType lp:R }} D ok.

pred field->unitRing o:term, o:term.
field->unitRing F U :- coq.unify-eq {{ GRing.Field.unitRingType lp:F }} U ok.

pred unitRing->ring o:term, o:term.
unitRing->ring U R :- coq.unify-eq {{ GRing.UnitRing.ringType lp:U }} R ok.

pred ring->zmod o:term, o:term.
ring->zmod R T :- coq.unify-eq {{ GRing.Ring.zmodType lp:R }} T ok.

% [field-mode] is true if we are on a realFieldType,
% otherwise we are on a realDomainType.
pred field-mode.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parse goal (and hypotheses) to extract a realFieldType or realDomainType
% from (in)equalities it contains

% ring or field structure from a term of type bool
pred rfstr.bool i:term, o:rf.
rfstr.bool {{ _ ==> lp:Type }} F :- rfstr.bool Type F.
rfstr.bool {{ lp:Type ==> _ }} F :- rfstr.bool Type F.
rfstr.bool {{ ~~ lp:Type }} F :- rfstr.bool Type F.
rfstr.bool {{ _ && lp:Type }} F :- rfstr.bool Type F.
rfstr.bool {{ lp:Type && _ }} F :- rfstr.bool Type F.
rfstr.bool {{ _ || lp:Type }} F :- rfstr.bool Type F.
rfstr.bool {{ lp:Type || _ }} F :- rfstr.bool Type F.
rfstr.bool {{ @Order.le _ lp:Ty _ _ }} F :- field-mode,
  rf->porder F Ty, F = field _.
rfstr.bool {{ @Order.lt _ lp:Ty _ _ }} F :- field-mode,
  rf->porder F Ty, F = field _.
rfstr.bool {{ @Order.le _ lp:Ty _ _ }} R :- not field-mode,
  rf->porder R Ty, R = ring _.
rfstr.bool {{ @Order.lt _ lp:Ty _ _ }} R :- not field-mode,
  rf->porder R Ty, R = ring _.

% ring or field structure from a term of type Prop
pred rfstr.prop i:term, o:rf.
rfstr.prop {{ _ -> lp:Type }} F :- rfstr.prop Type F.
rfstr.prop {{ lp:Type -> _ }} F :- rfstr.prop Type F.
rfstr.prop {{ iff _ lp:Type }} F :- rfstr.prop Type F.
rfstr.prop {{ iff lp:Type _ }} F :- rfstr.prop Type F.
rfstr.prop {{ ~ lp:Type }} F :- rfstr.prop Type F.
rfstr.prop {{ _ /\ lp:Type }} F :- rfstr.prop Type F.
rfstr.prop {{ lp:Type /\ _ }} F :- rfstr.prop Type F.
rfstr.prop {{ _ \/ lp:Type }} F :- rfstr.prop Type F.
rfstr.prop {{ lp:Type \/ _ }} F :- rfstr.prop Type F.
rfstr.prop {{ is_true lp:Type }} F :- rfstr.bool Type F.
rfstr.prop {{ @eq bool _ lp:Type }} F :- rfstr.bool Type F.
rfstr.prop {{ @eq bool lp:Type _ }} F :- rfstr.bool Type F.
rfstr.prop {{ @eq lp:Ty _ _ }} F :- field-mode, rf->sort F Ty, F = field _.
rfstr.prop {{ @eq lp:Ty _ _ }} R :- not field-mode, rf->sort R Ty, R = ring _.

pred rfstr.hyps i:list prop, o:rf.
rfstr.hyps [decl _ _ H|_] F :- rfstr.prop H F.
rfstr.hyps [_|Ctx] F :- rfstr.hyps Ctx F.

pred rfstr i:list prop, i:term, o:rf.
rfstr _ Type F :- field-mode => rfstr.prop Type F.
rfstr _ Type R :- rfstr.prop Type R.
rfstr Ctx _ F :- field-mode => rfstr.hyps Ctx F.
rfstr Ctx _ R :- rfstr.hyps Ctx R.
rfstr _ _ _ :- coq.ltac.fail _ "Cannot find a realDomainType".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Reification procedure

% [quote.cstr V In OutM Out] reifies integer constants
% - [V] is a [ringType]
% - [In] is a term of type [V],
% - [OutM] is a reified constant of type [MExpr V]
% - [Out] is a reified constant of type [PExpr Q]
pred quote.cstr i:term, i:term, o:term, o:term.
quote.cstr V {{ GRing.zero lp:Z }} OutM Out :- ring->zmod V Z,
  OutM = {{ @Internals.MEint lp:V Z0 }}, Out = {{ PEc (Qmake Z0 1) }}.
quote.cstr V {{ GRing.one lp:V' }} OutM Out :- coq.unify-eq V V' ok,
  OutM = {{ @Internals.MEint lp:V (Zpos 1) }}, Out = {{ PEc (Qmake 1 1) }}.
quote.cstr V {{ @GRing.natmul lp:Z (GRing.one lp:V') lp:X }} OutM Out :-
  ring->zmod V Z, coq.unify-eq V V' ok, nat->Z X XZ,
  OutM = {{ @Internals.MEint lp:V lp:XZ }}, Out = {{ PEc (Qmake lp:XZ 1) }}.

% [quote.cstf V In OutM Out] reifies rational constants
% - [V] is a [ringType] instance,
% - [In] is a term of type [V],
% - [OutM] is a reified constant of type [MExpr V]
% - [Out] is a reified constant of type [PExpr Q]
pred quote.cstf i:term, i:term, o:term, o:term.
quote.cstf V {{ @GRing.inv lp:U (@GRing.natmul lp:Z (GRing.one lp:V') lp:X) }}
    OutM Out :- unitRing->ring U V, ring->zmod V Z, coq.unify-eq V V' ok,
  nat->N X XN, XN = {{ Npos lp:XP }}, XQ = {{ Qmake 1 lp:XP }},
  field->unitRing F U,
  OutM = {{ @Internals.MErat lp:F lp:XQ }}, Out = {{ PEc lp:XQ }}.

% [quote.expr V F In OutM Out VM] reifies arithmetic expressions
% - [V] is a [ringType]
% - [F] is a function
% - [In] is a term of type [V],
% - [OutM] is a reified expression of type [MExpr V]
% - [Out] is a reified expression of type [PExpr Q]
% - [VM] is a variable map, that is a list of terms of type [V].
pred quote.expr i:term, i:(term -> term), i:term, o:term, o:term, o:list term.
quote.expr V F {{ @GRing.add lp:Z lp:In1 lp:In2 }} OutM Out VM :-
  ring->zmod V Z, !,
  quote.expr V F In1 OutM1 Out1 VM, !, quote.expr V F In2 OutM2 Out2 VM, !,
  OutM = {{ @Internals.MEadd lp:V lp:OutM1 lp:OutM2 }},
  Out = {{ PEadd lp:Out1 lp:Out2 }}.
quote.expr V F {{ @GRing.mul lp:V' lp:In1 lp:In2 }} OutM Out VM :-
  coq.unify-eq V V' ok, !,
  quote.expr V F In1 OutM1 Out1 VM, !, quote.expr V F In2 OutM2 Out2 VM, !,
  OutM = {{ @Internals.MEmul lp:V lp:OutM1 lp:OutM2 }},
  Out = {{ PEmul lp:Out1 lp:Out2 }}.
quote.expr V F {{ @GRing.opp lp:Z lp:In1 }} OutM Out VM :-
  ring->zmod V Z, !,
  quote.expr V F In1 OutM1 Out1 VM, !,
  OutM = {{ @Internals.MEopp lp:V lp:OutM1 }}, Out = {{ PEopp lp:Out1 }}.
quote.expr V F {{ @GRing.exp lp:V' lp:In1 lp:X }} OutM Out VM :-
  coq.unify-eq V V' ok, nat->N X XN, !,
  quote.expr V F In1 OutM1 Out1 VM, !,
  OutM = {{ @Internals.MEpow lp:V lp:OutM1 lp:XN }},
  Out = {{ PEpow lp:Out1 lp:XN }}.
quote.expr V _ In OutM Out _ :- quote.cstr V In OutM Out.
quote.expr V _ In OutM Out _ :- field-mode, quote.cstf V In OutM Out.
quote.expr V F In {{ @Internals.MEmorph lp:U lp:V lp:G lp:OutM }} Out VM :-
  coq.unify-eq
    {{ @GRing.RMorphism.apply lp:U lp:V lp:Ph lp:G lp:In1 }} In ok, !,
  quote.expr U (x\ F {{ @GRing.RMorphism.apply lp:U lp:V lp:Ph lp:G lp:x }})
    In1 OutM Out VM.
quote.expr V F In {{ @Internals.MEX lp:V lp:In }} {{ PEX lp:N }} VM :- !,
  mem VM (F In) N.

% [quote.exprw F In OutM Out VM] reifies arithmetic expressions
% - [F] is a [realDomainType] or [realFieldType] instance,
% - [In] is a term of type [F],
% - [OutM] is a reified expression of type [MExpr F]
% - [Out] is a reified expression of type [PExpr Q]
% - [VM] is a variable map, that is a list of terms of type [F].
pred quote.exprw i:rf, i:term, o:term, o:term, o:list term.
quote.exprw F In OutM Out VM :- F = field _, !,
  field-mode => quote.expr { rf->ring F } (x\ x) In OutM Out VM.
quote.exprw F In OutM Out VM :- F = ring _, !,
  quote.expr { rf->ring F } (x\ x) In OutM Out VM.

% [quote.bop2 F In OutM Out VM] reifies boolean (in)equalities
% - [F] is a [realDomainType] or [realFieldType] instance,
% - [In] is a term of type [bool],
% - [OutM] is a reified expression of type [MFormula]
% - [Out] is a reified expression of type [Formula Q]
% - [VM] is a variable map, that is a list of terms of type [F].
pred quote.bop2 i:rf, i:term, o:term, o:term, o:list term.
quote.bop2 F {{ @Order.le _ lp:O lp:X lp:Y }} OutM Out VM :- rf->porder F O, !,
  quote.exprw F X XM' X' VM, !, quote.exprw F Y YM' Y' VM, !,
  OutM = {{ Internals.Build_MFormula lp:XM' OpLe lp:YM' }},
  Out = {{ Build_Formula lp:X' OpLe lp:Y' }}.
quote.bop2 F {{ @Order.lt _ lp:O lp:X lp:Y }} OutM Out VM :- rf->porder F O, !,
  quote.exprw F X XM' X' VM, !, quote.exprw F Y YM' Y' VM, !,
  OutM = {{ Internals.Build_MFormula lp:XM' OpLt lp:YM' }},
  Out = {{ Build_Formula lp:X' OpLt lp:Y' }}.
quote.bop2 F {{ @eqtype.eq_op lp:T lp:X lp:Y) }} OutM Out VM :- rf->eq F T, !,
  quote.exprw F X XM' X' VM, !, quote.exprw F Y YM' Y' VM, !,
  OutM = {{ Internals.Build_MFormula lp:XM' OpEq lp:YM' }},
  Out = {{ Build_Formula lp:X' OpEq lp:Y' }}.

% [quote.pop2 F In OutM Out VM] reifies (in)equalities of type Prop
% - [F] is a [realDomainType] or [realFieldType] instance,
% - [In] is a term of type [Prop],
% - [OutM] is a reified expression of type [MFormula]
% - [Out] is a reified expression of type [Formula Q]
% - [VM] is a variable map, that is a list of terms of type [F].
pred quote.pop2 i:rf, i:term, o:term, o:term, o:list term.
quote.pop2 F {{ is_true lp:E }} OutM Out VM :- quote.bop2 F E OutM Out VM.
quote.pop2 F {{ @eq lp:T lp:X lp:Y) }} OutM Out VM :- rf->sort F T, !,
  quote.exprw F X XM' X' VM, !, quote.exprw F Y YM' Y' VM, !,
  OutM = {{ Internals.Build_MFormula lp:XM' OpEq lp:YM' }},
  Out = {{ Build_Formula lp:X' OpEq lp:Y' }}.

% [quote.bool F In OutM Out VM] reifies boolean formulas
% - [F] is a [realDomainType] or [realFieldType] instance,
% - [In] is a term of type [bool],
% - [OutM] is a reified formula of type [BFormula MFormula Tauto.isBool]
% - [Out] is a reified formula of type [BFormula (Formula Q) Tauto.isBool]
% - [VM] is a variable map, that is a list of terms of type [F].
pred quote.bool i:rf, i:term, o:term, o:term, o:list term.
quote.bool F {{ lp:F1 ==> lp:F2 }} OutM Out VM :- !,
  quote.bool F F1 OutM1 Out1 VM, !, quote.bool F F2 OutM2 Out2 VM, !,
  OutM = {{ IMPL lp:OutM1 None lp:OutM2 }},
  Out = {{ IMPL lp:Out1 None lp:Out2 }}.
quote.bool F {{ lp:F1 && lp:F2 }} OutM Out VM :- !,
  quote.bool F F1 OutM1 Out1 VM, !, quote.bool F F2 OutM2 Out2 VM, !,
  OutM = {{ AND lp:OutM1 lp:OutM2 }}, Out = {{ AND lp:Out1 lp:Out2 }}.
quote.bool F {{ lp:F1 || lp:F2 }} OutM Out VM :- !,
  quote.bool F F1 OutM1 Out1 VM, !, quote.bool F F2 OutM2 Out2 VM, !,
  OutM = {{ OR lp:OutM1 lp:OutM2 }}, Out = {{ OR lp:Out1 lp:Out2 }}.
quote.bool F {{ ~~ lp:F1 }} OutM Out VM :- !, quote.bool F F1 OutM1 Out1 VM, !,
  OutM = {{ NOT lp:OutM1 }}, Out = {{ NOT lp:Out1 }}.
quote.bool _ {{ true }} OutM Out _ :- !,
  OutM = {{ TT Tauto.isBool }}, Out = {{ TT Tauto.isBool }}.
quote.bool _ {{ false }} OutM Out _ :- !,
  OutM = {{ FF Tauto.isBool }}, Out = {{ FF Tauto.isBool }}.
quote.bool F In OutM Out VM :- quote.bop2 F In OutM' Out' VM,
  OutM = {{ A Tauto.isBool lp:OutM' tt }},
  Out = {{ A Tauto.isBool lp:Out' tt }}.
quote.bool _ In OutM Out _ :-
  OutM = {{ X Tauto.isBool lp:In }}, Out = {{ X Tauto.isBool lp:In }}.

% [quote.prop F In OutM Out VM] reifies formulas of type Prop
% - [F] is a [realDomainType] or [realFieldType] instance,
% - [In] is a term of type [Prop],
% - [OutM] is a reified formula of type [BFormula MFormula Tauto.isProp]
% - [Out] is a reified formula of type [BFormula (Formula Q) Tauto.isProp]
% - [VM] is a variable map, that is a list of terms of type [F].
pred quote.prop i:rf, i:term, o:term, o:term, o:list term.
quote.prop F {{ lp:F1 -> lp:F2 }} OutM Out VM :- !,
  quote.prop F F1 OutM1 Out1 VM, !, quote.prop F F2 OutM2 Out2 VM, !,
  OutM = {{ IMPL lp:OutM1 None lp:OutM2 }},
  Out = {{ IMPL lp:Out1 None lp:Out2 }}.
quote.prop F {{ iff lp:F1 lp:F2 }} OutM Out VM :- !,
  quote.prop F F1 OutM1 Out1 VM, !, quote.prop F F2 OutM2 Out2 VM, !,
  OutM = {{ IFF lp:OutM1 lp:OutM2 }}, Out = {{ IFF lp:Out1 lp:Out2 }}.
quote.prop F {{ lp:F1 /\ lp:F2 }} OutM Out VM :- !,
  quote.prop F F1 OutM1 Out1 VM, !, quote.prop F F2 OutM2 Out2 VM, !,
  OutM = {{ AND lp:OutM1 lp:OutM2 }}, Out = {{ AND lp:Out1 lp:Out2 }}.
quote.prop F {{ lp:F1 \/ lp:F2 }} OutM Out VM :- !,
  quote.prop F F1 OutM1 Out1 VM, !, quote.prop F F2 OutM2 Out2 VM, !,
  OutM = {{ OR lp:OutM1 lp:OutM2 }}, Out = {{ OR lp:Out1 lp:Out2 }}.
quote.prop F {{ ~ lp:F1 }} OutM Out VM :- !, quote.prop F F1 OutM1 Out1 VM, !,
  OutM = {{ NOT lp:OutM1 }}, Out = {{ NOT lp:Out1 }}.
quote.prop _ {{ True }} OutM Out _ :- !,
  OutM = {{ TT Tauto.isProp }}, Out = {{ TT Tauto.isProp }}.
quote.prop _ {{ False }} OutM Out _ :- !,
  OutM = {{ FF Tauto.isProp }}, Out = {{ FF Tauto.isProp }}.
quote.prop F {{ is_true lp:In1 }} OutM Out VM :- !,
  quote.bool F In1 OutM1 Out1 VM, !,
  OutM = {{ EQ lp:OutM1 (TT Tauto.isBool) }},
  Out = {{ EQ lp:Out1 (TT Tauto.isBool) }}.
quote.prop F {{ @eq bool lp:In1 lp:In2 }} OutM Out VM :- !,
  quote.bool F In1 OutM1 Out1 VM, !, quote.bool F In2 OutM2 Out2 VM,
  OutM = {{ EQ lp:OutM1 lp:OutM2 }}, Out = {{ EQ lp:Out1 lp:Out2 }}.
quote.prop F In OutM Out VM :- quote.pop2 F In OutM' Out' VM,
  OutM = {{ A Tauto.isProp lp:OutM' tt }},
  Out = {{ A Tauto.isProp lp:Out' tt }}.
quote.prop _ In OutM Out _ :-
  OutM = {{ X Tauto.isProp lp:In }}, Out = {{ X Tauto.isProp lp:In }}.

% [simplify.bool In Out] reduces a boolean formula to [X _]
% when it doesn't contain any arithmetic part
% - [In] is a reified formula of type [BFormula _ Tauto.isBool],
% - [Out] is a simplified formula of type [BFormula _ Tauto.isBool]
pred simplify.bool i:term, o:term.
simplify.bool {{ IMPL (X _ lp:F1) None (X _ lp:F2) }} F' :-
  F' = {{ X Tauto.isBool (lp:F1 ==> lp:F2) }}.
simplify.bool {{ IMPL lp:F1 None lp:F2 }} {{ IMPL lp:F1' None lp:F2' }} :-
  simplify.bool F1 F1', simplify.bool F2 F2'.
simplify.bool {{ AND (X _ lp:F1) (X _ lp:F2) }} F' :-
  F' = {{ X Tauto.isBool (lp:F1 && lp:F2) }}.
simplify.bool {{ AND lp:F1 lp:F2 }} {{ AND lp:F1' lp:F2' }} :-
  simplify.bool F1 F1', simplify.bool F2 F2'.
simplify.bool {{ OR (X _ lp:F1) (X _ lp:F2) }} F' :-
  F' = {{ X Tauto.isBool (lp:F1 || lp:F2) }}.
simplify.bool {{ OR lp:F1 lp:F2 }} {{ OR lp:F1' lp:F2' }} :-
  simplify.bool F1 F1', simplify.bool F2 F2'.
simplify.bool {{ NOT (X _ lp:F) }} {{ X Tauto.isProp (~~ lp:F) }}.
simplify.bool {{ NOT lp:F }} {{ NOT lp:F' }} :- simplify.bool F F'.
simplify.bool X X.

% [simplify.prop In Out] reduces a formula to [X _]
% when it doesn't contain any arithmetic part
% - [In] is a reified formula of type [BFormula _ Tauto.isProp],
% - [Out] is a simplified formula of type [BFormula _ Tauto.isProp]
pred simplify.prop i:term, o:term.
simplify.prop {{ IMPL (X _ lp:F1) None (X _ lp:F2) }} F' :-
  F' = {{ X Tauto.isProp (lp:F1 -> lp:F2) }}.
simplify.prop {{ IMPL lp:F1 None lp:F2 }} {{ IMPL lp:F1' None lp:F2' }} :-
  simplify.prop F1 F1', simplify.prop F2 F2'.
simplify.prop {{ IFF (X _ lp:F1) (X _ lp:F2) }} F' :-
  F' = {{ X Tauto.isProp (iff lp:F1 lp:F2) }}.
simplify.prop {{ IFF lp:F1 lp:F2 }} {{ IFF lp:F1' lp:F2' }} :-
  simplify.prop F1 F1', simplify.prop F2 F2'.
simplify.prop {{ AND (X _ lp:F1) (X _ lp:F2) }} F' :-
  F' = {{ X Tauto.isProp (lp:F1 /\ lp:F2) }}.
simplify.prop {{ AND lp:F1 lp:F2 }} {{ AND lp:F1' lp:F2' }} :-
  simplify.prop F1 F1', simplify.prop F2 F2'.
simplify.prop {{ OR (X _ lp:F1) (X _ lp:F2) }} F' :-
  F' = {{ X Tauto.isProp (lp:F1 \/ lp:F2) }}.
simplify.prop {{ OR lp:F1 lp:F2 }} {{ OR lp:F1' lp:F2' }} :-
  simplify.prop F1 F1', simplify.prop F2 F2'.
simplify.prop {{ NOT (X _ lp:F) }} {{ X Tauto.isProp (~ lp:F) }}.
simplify.prop {{ NOT lp:F }} {{ NOT lp:F' }} :- simplify.prop F F'.
simplify.prop {{ EQ (X _ lp:F1) (X _ lp:F2) }} F' :-
  F' = {{ X Tauto.isProp (lp:F1 = lp:F2) }}.
simplify.prop {{ EQ lp:F1 lp:F2 }} {{ EQ lp:F1' lp:F2' }} :-
  simplify.bool F1 F1', simplify.bool F2 F2'.
simplify.prop X X.

% [quote F In Out VM] reifies formulas of type Prop
% - [F] is a [realDomainType] or [realFieldType] instance,
% - [In] is a term of type [Prop],
% - [OutM] is a reified formula of type [BFormula MFormula Tauto.isProp]
% - [Out] is a reified formula of type [BFormula (Formula Q) Tauto.isProp]
% - [VM] is a variable map, that is a list of terms of type [F].
pred quote i:rf, i:term, o:term, o:term, o:list term.
quote F In OutM' Out' VM :-
  quote.prop F In OutM Out VM, simplify.prop OutM OutM', simplify.prop Out Out'.

% [quote.hyps F Hyps Goal ReifiedGoal Out ReifiedOut VM] reifies hypotheses
% - [F] is a [realDomainType] or [realFieldType] instance,
% - [Hyps] are hypotheses
% - [Goal] is the goal, of type [Prop]
% - [ReifiedGoalM] is the refied goal as a [BFormula MFormula Tauto.isProp]
% - [ReifiedGoal] is the refied goal as a [BFormula (Formula Q) Tauto.isProp]
% - [Out] is a chain of implications including [Goal] and hypotheses in [Hyps]
%   that have some arithmetic content
% - [ReifiedOutM] is a reified version of [Out]
%   as a [BFormula MFormula Tauto.isProp]
% - [ReifiedOut] is a reified version of [Out]
%   as a [BFormula (Formula Q) Tauto.isProp]
% - [VM] is a variable map, that is a list of terms of type [F].
pred quote.hyps i:rf, i:list prop, i:term, i:term, i:term,
  o:term, o:term, o:term, o:list term.
quote.hyps F [decl _ _ H|Ctx] Type TypeFM TypeF Type'' TypeFM'' TypeF'' VM :-
  quote F H HM' H' VM, not (H' = {{ X _ _ }}), !,
  quote.hyps F Ctx Type TypeFM TypeF Type' TypeFM' TypeF' VM,
  Type'' = {{ lp:H -> lp:Type' }},
  TypeFM'' = {{ IMPL lp:HM' None lp:TypeFM' }},
  TypeF'' = {{ IMPL lp:H' None lp:TypeF' }}.
quote.hyps F [decl _ _ _|Ctx] Type TypeFM TypeF Type' TypeFM' TypeF' VM :- !,
  quote.hyps F Ctx Type TypeFM TypeF Type' TypeFM' TypeF' VM.
quote.hyps F [def _ _ _ _|Ctx] Type TypeFM TypeF Type' TypeFM' TypeF' VM :- !,
  quote.hyps F Ctx Type TypeFM TypeF Type' TypeFM' TypeF' VM.
quote.hyps _ [] Type TypeFM TypeF Type TypeFM TypeF _.

% [exfalso_if_not_prop In Out Bool] changes [In] to [False]
% when [In] is not a [Prop] (and then set [Bool] to [true])
pred exfalso_if_not_prop i:term, o:term, o:term.
exfalso_if_not_prop Type Type {{ false }} :-
  coq.typecheck Type {{ Prop }} ok.
exfalso_if_not_prop _ {{ False }} {{ true }}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Main tactic

% The tactic takes three arguments, two strings [TacF] and [TacR]
% that are the names of the Ltac1 tactic to call respactively
% in the [realFieldType] and [realDomainType] case and a third argument [N],
% passed unchanged as first argument to the previous tactic.
% The tactics [TacF] or [TacR] will receive six arguments:
% - [N] above
% - [Efalso] a term of type [bool] indicating if the goal was changed to [False]
% - [Type''] a term of type [Prop], an implication with the goal
%   and selected hypotheses
% - [TypeFM'] the reified [Type''] as a [BFormula MFormula Tauto.isProp]
% - [TypeF'] the reified [Type''] as a [BFormula (Formula Q) Tauto.isProp]
% - [VM''] a variable map, giving the interpretation to variables in [TypeF']
%   it is of type [VarMap.t F] where [F] is the carrier for the detected
%   [realFieldType] or [realDomainType]
solve (goal Ctx _Trigger Type _Proof [str TacF, str TacR, N] as G) GL :-
  exfalso_if_not_prop Type Type' Efalso,
  std.rev Ctx Ctx', !,
  rfstr Ctx' Type' F, !,
  quote F Type' TypeFM TypeF VM, !,
  quote.hyps F Ctx' Type' TypeFM TypeF Type'' TypeFM' TypeF' VM, !,
  rf->numDomain F NDF,
  std.assert-ok!
    (coq.typecheck TypeFM' {{ BFormula (@Internals.MFormula lp:NDF) isProp }})
    "The reification produced an ill-typed result, this is a bug.",
  std.assert-ok!
    (coq.typecheck TypeF' {{ BFormula (Formula Q) isProp }})
    "The reification produced an ill-typed result, this is a bug.",
  rf->sort F FS, list-constant FS VM VM',
  coq.reduction.vm.norm
    {{ Internals.vm_of_list lp:VM' }}
    {{ VarMap.t lp:FS }}
    VM'',
  (if (F = field _) (Tac = TacF) (Tac = TacR)),
  (coq.ltac.call
     Tac [N, trm Efalso, trm Type'', trm TypeFM', trm TypeF', trm VM''] G GL;
   coq.ltac.fail 0).
